---
title: "Validation Points - Post-processing"
author: "Jill Deines"
date: "Sunday, May 29, 2016"
output: 
  html_document:
    toc: yes
---

Goal: Take the KML exported from GEE during validation point creation and post-process


```{r knitrOpts, echo=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE, cache.path='cache/1.2_vPOintsPost/',
               fig.path='figure/1.2_vPointsPost/')
```

**R Packages Needed**

```{r packages, message=FALSE, echo=TRUE}
library(rgdal)
library(rgeos)
```

## Functions

### Process validation points: function
Wrote out imported GEE points as a csv (since the kml write=out doesn't include a layer name). This extracts coordinates, adds crop class name, and turns back into points to write out as a KML to add to GEE as a feature collection.

```{r csvFun}
# testFile <- 'C:/Users/deinesji/Google Drive/GEE_validation/valid_midRep_10_2010_JMDtest.csv'
# cdlKey <- read.csv('S:/Users/deinesji/HPA/gis/CDL/CDL_key_2014.csv', 
#                    stringsAsFactors=F)

csvToSpdf <- function(csvFilename, cdlKey){
    # load output from GEE
    validated <- read.csv(csvFilename, stringsAsFactors=F)

    # extract coordinates from messy .geo string
    coords <- sub(".*\\[(.*)\\].*", "\\1", validated$.geo, perl=TRUE)
    coords2 <- do.call(rbind, strsplit(coords, ','))   
    validated2 <- data.frame(class = validated$class,
                             classNum = validated$classNum,
                             certainty = validated$certainty,
                             CDLcode = validated$max,
                             x = as.numeric(coords2[,1]),
                             y = as.numeric(coords2[,2]),
                             system.index = validated$system.index)

    # add CDL class name
    validated3 <- merge(validated2, cdlKey[,c('VALUE','CLASS_NAME')], 
                    by.x = 'CDLcode', by.y='VALUE', all.y=F)
   
    # spatialize points
    coordinates(validated3) <- ~ x + y
    proj4string(validated3) <- "+proj=longlat +datum=WGS84"
    
    return(validated3)
  }

#test <- csvToSpdf(testFile, cdlKey)

```


## Csv to KMl
This section converts datasets exported from GEE as .csv's to spdfs using above function, then writes out as KML's for future import/use as fusion tables in GEE.

Note that validation files prior to the 'valid3' versions won't work with the function as written above (valid3 added additional columns)

```{r csvToKML, eval=FALSE}
cdlKey <- read.csv('S:/Users/deinesji/HPA/gis/CDL/CDL_key_2014.csv', 
                    stringsAsFactors=F)

# Jeremy's first full validation set for NE MidRep NRD
# irrigated and nonirrigated points only (uncertain omitted from export)
fileDir <- 'C:/Users/deinesji/Google Drive/GEE_validation/'
valid1 <- paste0(fileDir, 'valid_midRep_10_2010_jrapp_noUncertainty.csv')
valid1.spdf <- csvToSpdf(valid1, cdlKey)
# remove built/water classes
remove <- c(63, 82, 83, 111, 121, 122, 123, 124, 141, 142, 143)
valid1.spdf <- valid1.spdf[!(valid1.spdf$CDLcode %in% remove),]
# make class2 column
noncropCdl <- c(64, 87, 88, 152, 176, 190, 195)
valid1.spdf$class2 <- 1
for (i in 1:nrow(valid1.spdf)){
          if(valid1.spdf$irrigated[i] == "N") valid1.spdf[i,'class2'] <- 0
          if(valid1.spdf$CDLcode[i] %in% noncropCdl) valid1.spdf[i,'class2'] <- 2
  }
# remove system.index column
valid1.spdf<- valid1.spdf[,-3]

writeOGR(valid1.spdf, paste0(fileDir, 'valid_midRep_10_2010_jrapp_noUncertainty.kml'),
            layer = 'validPoints', driver = 'KML')
```


## Point Validation Evaluation
Undergrad Jeremy Rapp evaluated ~980 random points in the Middle Republican NRD. To compare irrigated/nonirrigated classifications between investigators, Jill recorded 222 points. This compares them.

### First trial: binary classification approach
Note this won't work as written after csvToSpdf function update for valid3 versions

```{r compare1}
# crop key
cdlKey <- read.csv('S:/Users/deinesji/HPA/gis/CDL/CDL_key_2014.csv', 
                    stringsAsFactors=F)

# Jeremey's file
rappFile <-'C:/Users/deinesji/Google Drive/GEE_validation/valid_midRep_10_2010_jrapp.csv'
# Jill's file
jillFile <- 'C:/Users/deinesji/Google Drive/GEE_validation/valid_midRep_10_2010_JMDtest.csv'

# load/process csvs to spatial points
rappPoints <- csvToSpdf(rappFile, cdlKey)
jillPoints <- csvToSpdf(jillFile, cdlKey)

# project to meters
rappPoints <- spTransform(rappPoints, CRS('+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs '))
jillPoints <- spTransform(jillPoints, CRS('+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs '))

# find distances between all points
distPairs <- as.data.frame(gDistance(jillPoints, rappPoints, byid = T))
distPairs$cellnum <- 1:nrow(distPairs)

# best guess at paired points
pointBuddies <- data.frame(jill = 1:222, rapp = NA, crop = jillPoints$CLASS_NAME,
                           jillIrr = jillPoints$irrigated, rappIrr = NA)
for (i in 1:222) {
  pointBuddies[i,'rapp'] <- distPairs[which.min(distPairs[,i]),'cellnum']
}
  
# add irrigation status for rapp
rappPoints$ind <- 1:nrow(rappPoints)
pointBuds <- merge(pointBuddies, rappPoints[,c('irrigated','ind')],
                   by.x = 'rapp', by.y='ind', all.y = F)
pointBuds$rappIrr <- pointBuds$irrigated

# summarize agreement
totalMatching <- sum(pointBuds$rappIrr == pointBuds$jillIrr)
# percent matching
totalMatching/222

# tabulate crop
pointBuds$identical <- pointBuds$rappIrr == pointBuds$jillIrr
table(pointBuds[,c('crop','identical')])
```


### Second trial: 3-level uncertainty approach
First evaluation on August 22, 2016: neither Jeremy or Jill finished whole set


```{r compare2}
# crop key
cdlKey <- read.csv('S:/Users/deinesji/HPA/gis/CDL/CDL_key_2014.csv', 
                    stringsAsFactors=F)

# Jeremey's file
rappFile <-'C:/Users/deinesji/Google Drive/GEE_validation/valid3_midRep_10_2010_jrappTest.csv'
# Jill's file
jillFile <- 'C:/Users/deinesji/Google Drive/GEE_validation/valid3_midRep_10_2010_jmdTest.csv'

# load/process csvs to spatial points
rappPoints <- csvToSpdf(rappFile, cdlKey)
jillPoints <- csvToSpdf(jillFile, cdlKey)

# project to meters
rappPoints <- spTransform(rappPoints, CRS('+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs '))
jillPoints <- spTransform(jillPoints, CRS('+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=37.5 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=m +no_defs '))

# find distances between all points
distPairs <- as.data.frame(gDistance(jillPoints, rappPoints, byid = T))
distPairs$cellnum <- 1:nrow(distPairs)

# best guess at paired points
pointBuddies <- data.frame(jill = 1:nrow(jillPoints), rapp = NA, distance = NA,
                           crop = jillPoints$CLASS_NAME,
                           jillclass = jillPoints$class, 
                           rappclass = NA,
                           jillcert = jillPoints$certainty,
                           rappcert = NA)

for (i in 1:nrow(jillPoints)) {
  pointBuddies[i,'rapp'] <- distPairs[which.min(distPairs[,i]),'cellnum']
  pointBuddies[i, 'distance'] <- distPairs[which.min(distPairs[,i]),i]
}
  
# add irrigation status (class) and certainty for rapp
rappPoints$ind <- 1:nrow(rappPoints)
pointBuds <- merge(pointBuddies, rappPoints[,c('class','certainty','ind')],
                   by.x = 'rapp', by.y='ind', all.y = F)
pointBuds$rappclass <- pointBuds$class
pointBuds$rappcert <- pointBuds$certainty

# filter for reasonable distances
pointBuds <- pointBuds[pointBuds$distance < 200,]

# summarize agreement
totalMatching <- sum(pointBuds$rappclass == pointBuds$jillclass)
# percent matching
totalMatching/nrow(pointBuds)

# tabulate crop
pointBuds$identical <- pointBuds$rappIrr == pointBuds$jillIrr
table(pointBuds[,c('crop','identical')])
```
