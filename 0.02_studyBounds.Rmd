---
title: "Study Bounds"
author: "Jill Deines"
date: "June 29, 2017"
output: 
  html_document:
    toc: yes
---

Goal: Document full production of study area boundary, and evaluate the number of counties various options include for a robust county validation. This aggregates study bound polygon generation from several sources prior to manuscript revisions. It also incorporates the area calculations from the old 0.01_polygonAreaFinder.R script.

```{r knitrOpts, echo=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE,
               fig.path='figure/0.02_studyBounds/')
```

**R Packages Needed**

```{r packages, message=FALSE, echo=TRUE}
library(rgdal)
library(rgeos)
library(raster)
```



## Model boundary: uniform buffer
This is a new boundary created 6/29/2017 for manuscript revisions. Load RRCA groundwater model boundary and RRB basin boundary, union, then apply a uniform buffer to the full region.

Buffer distances will be calculated using `CRS('+init=epsg:5070'))`, CONUS albers equal area, to be consistent with final map outputs.

Note: The RRCA boundary used here is the HPA Aquifer polygon, manually clipped to the Platte/RRCA model bound in the northern edge, and the RRCA bound in the southern edge, in ArcGIS by J Deines. The purpose of this is to have actual aquifer boundaries along the Eastern, Western, and partial southern borders instead of a boundary based on the 1 mile cells in the RRCA model, with its associated holes and weirdnesses.

```{r loadBounds}
gisDir <- 'S:/Users/deinesji/HPA/gis'
# load bound used for first submission for comparison
original <-  readOGR(gisDir, 'BigExtent_RRB_RRCA_buff', verbose=F)

# rrca bound exported from model
bound <- readOGR(gisDir, 'Aquifer_RRCA_manualClip', verbose=F)

# republican basin
rrb <- readOGR(gisDir, 'RepBasin', verbose=F)

# reproject
aeaProj <- '+init=epsg:5070'
bound <- spTransform(bound, CRS(aeaProj)) 
rrb <- spTransform(rrb, CRS(aeaProj))
original <- spTransform(original, CRS(aeaProj))

# union and keep as spdf
unioned <- gUnion(bound,rrb)
unioned <- SpatialPolygonsDataFrame(unioned, match.ID=F,
                                         data.frame(name='union'))

# buffer options --------------------------------------------------
# get lateral width
boundwidth <- abs(bbox(unioned)[2,1]-bbox(unioned)[2,2])
percent10 <- boundwidth*.1

# buffer and reformat
buffer10p <- gBuffer(unioned, width=percent10)
buffer10p <- SpatialPolygonsDataFrame(buffer10p, match.ID=F,
                                         data.frame(name='buffered'))

# minimum buffer: rrb matching
buff <- 10000
bufferSmall <- gBuffer(unioned, width=buff)
bufferSmall <- SpatialPolygonsDataFrame(bufferSmall, match.ID=F,
                                         data.frame(name='buffered'))
# make minute adjustments since original data was buffered in HPA class projection
bufferSmall2 <- raster::intersect(bufferSmall, original)

# visualize
par(mar=c(2,0,0,0))
plot(original, border='blue')
plot(buffer10p, border = 'red',add=T)
plot(bufferSmall2, add=T)
plot(unioned, col='gray80',border='gray80',add=T)
plot(bound, border='gray50', add=T)
legend('bottom',legend = c('original','10 percent','10 km','union'), 
       col = c('blue','red','black','gray80'), lty=1, ncol=4)
#plot(unioned, add=T)
```

## County Analyses
See how buffer choices affect the number of fully included counties

```{r countyCheck}
# county shapefile
tigerDir <- 'S:/Data/GIS_Data/Downloaded/TIGER/TIGER2012/COUNTY'
tigerName <- 'tl_2012_us_county'
counties <- readOGR(tigerDir, tigerName, verbose=F)
counties <- spTransform(counties, CRS(aeaProj))

# subset columns and add 5 digit fips
columnsToKeep <- c('STATEFP','COUNTYFP','COUNTYNS','NAME')
counties <- counties[,columnsToKeep]
counties$fips5 <- paste0(counties$STATEFP, counties$COUNTYFP)


# function to return counties 100% within polygons
getInCounties <- function(aoi0, countyAll, threshold = .999, tolerance = -100){
  #do a slight negative buffer to avoid line mismatches
  aoi <- gBuffer(aoi0, width=tolerance)
  # subset counties by aoi (all counties with any overlap)
  counties.overlap <- countyAll[aoi,]
  # crop counties by aoi
  countyCrop  <- raster::intersect(countyAll, aoi)
  # find the proportion of each county within the aoi by getting the area of
  # both and dividing
  counties.overlap$area_km2 <- round(gArea(counties.overlap, byid=T)/1000000)
  countyCrop$area_km2 <- round(gArea(countyCrop, byid=T)/1000000)
  countyCrop$proportion <- countyCrop$area_km2/counties.overlap$area_km2
  countiesIn <- countyCrop[countyCrop$proportion > threshold,]
  return(countiesIn)
}

# get counties by boundary: original
county.original <- getInCounties(original, counties, threshold=.999)
nrow(county.original)
plot(counties[original,], main = 'Original 35 Counties Used')
plot(original, border = 'blue', add=T)
plot(county.original, col='red', add=T)

county.original37 <- getInCounties(original, counties, threshold=.99)
nrow(county.original37)
plot(counties[original,], main = 'Original, 37 Counties Option')
plot(original, border = 'blue', add=T)
plot(county.original37, col='red', add=T)

# get counties by boundary: strict untion
county.union <- getInCounties(unioned, counties, threshold=.999)
nrow(county.union)
plot(counties[unioned,], main = 'Unioned Counties: 20')
plot(unioned, border = 'blue', add=T)
plot(county.union, col='red', add=T)

# get counties by boundary: smallest consensus buffer
county.10km <- getInCounties(bufferSmall2, counties, threshold=.999)
nrow(county.10km)
plot(counties[bufferSmall2,], main = '10 km buffer Counties: 25')
plot(bufferSmall2, border = 'blue', add=T)
plot(county.10km, col='red', add=T)

# get counties by boundary: biggest consensus buffer
county.10p <- getInCounties(buffer10p, counties, threshold=.999)
nrow(county.10p)
plot(counties[buffer10p,], main = '10% buffer Counties: 34')
plot(buffer10p, border = 'blue', add=T)
plot(county.10p, col='red', add=T)

# counties combined
par(mar=c(2,0,2,2))
#plot(county.original, border='green', main = 'County Comparison')
plot(county.10p, col = 'gray20', main = 'county comparison')
plot(county.original, border='green', add=T)
plot(county.10km, col='blue', add=T)
plot(county.union, col='red', add=T)
legend('bottom', legend = c('original','10%','10 km','union'),
       fill = c('green','gray20','blue','red'), ncol=4)

# export a list of fips for each option
maxrow <- nrow(county.original37)
fips = data.frame(original37 = as.character(county.original37$fips5),
                  original = as.character(c(county.original$fips5,
                                            rep(NA, maxrow-nrow(county.original)))),
                  union = as.character(c(county.union$fips5, 
                                         rep(NA, maxrow-nrow(county.union)))),
                  p10 = as.character(c(county.10p$fips5, 
                                       rep(NA, maxrow - nrow(county.10p)))),
                  km10 = as.character(c(county.10km$fips5, 
                                        rep(NA, maxrow - nrow(county.10km)))))

# export
outDir <- 'C:/Users/deinesji/Dropbox/1PhdJill/hpa/irrigation/data/GIS/kml/FINAL_BOUNDARIES'
write.csv(fips, paste0(outDir,'/boundary_options_fips_for_contained_countyies.csv'),
          row.names=F)
```

## Areal Comparisons
Compare study areas (since mapping a large area is part of our novelty). Calculates are in AEA conus, as maps are presented

```{r areas}
# RRCA km^2
gArea(bound) * 1e-6

# RRB k^2
gArea(rrb) * 1e-6

# original manuscript study area (uneven buffer)
gArea(original) * 1e-6

# union
gArea(unioned) * 1e-6

# small buffer (10 km)
gArea(bufferSmall2) * 1e-6

# large buffer (10 percent of union width, ish)
gArea(buffer10p) * 1e-6
```



## EXport
including breaking down some regions by state

```{r export}
# Export boundaries and county options
outDir <- 'C:/Users/deinesji/Dropbox/1PhdJill/hpa/irrigation/data/GIS/kml/FINAL_BOUNDARIES'

# boundary options ---------------------------------------------------------
# rrca/rrb union (main study area)
unioned$masterID <- 'RRCA_RRB_Union'
#writeOGR(unioned, outDir, 'RRCA_RRB_union_aea', driver='ESRI Shapefile')

# manually created RRCA bound to Dropbox
bound$masterID <- 'RRCA_modifiedBorders'
bound <- bound[,c('masterID')]
#writeOGR(bound, outDir, 'RRCA_modified_aea', driver='ESRI Shapefile')

# RRB to Dropbox for completeness
rrb$masterID <- 'RRB_basin'
#writeOGR(rrb, outDir, 'RRB_aea', driver='ESRI Shapefile')

# sub-regions by state ----------------------------------------------------
# manual moddified RRCA (hpa + RRCA) -----------------
stateDir <- 'C:/Users/deinesji/Dropbox/1PhdJill/hpa/irrigation/data/GIS/kml/shapefile'
states <- readOGR(stateDir, 'States', verbose=F)
states <- spTransform(states, CRS(aeaProj))
rrcastates <- raster::intersect(states, bound)
rrcastates <- rrcastates[,c('STATE_NAME','STATE_FIPS','STATE_ABBR')]
rrcastates$masterID <- as.factor(c('RRCA_mod_NE', 'RRCA_mod_CO','RRCA_mod_KS'))
spplot(rrcastates, 'masterID')


#writeOGR(rrcastates, outDir, 'RRCA_modified_byState_aea', driver='ESRI Shapefile')

# RRB by state --------------------
rrbstates <- raster::intersect(states, rrb)
rrbtail <- gDifference(rrb,bound)

# gut check: splitting KS "upper" and "lower" sections doesn't 100% coincide with 
# aquifer/non-aquifer
plot(rrbstates, col='blue',main = 'Non-aquifer RRB in red')
plot(rrbtail, add=T, col='red')
plot(bound, add=T)

# regardless, split
rrbstates2 <- disaggregate(rrbstates)
rrbstates2$aream2 <- gArea(rrbstates2, byid=T) # check polygon areas
rrbstates2$areakm2 <-rrbstates2$aream2 * 1e-6
rrbstates3 <- rrbstates2[rrbstates2$aream2 > 5000,] # remove sliver polygon 
rrbstates3$STATE_NAME <- as.factor(c('Nebraska','Colorado','Kansas_Upper','Kansas_Lower'))

spplot(rrbstates3,'STATE_NAME', col.regions=bpy.colors(4), main='basin split')

#export
rrbstates3$masterID <- c('RRB_NE_basin','RRB_CO_basin','RRB_KS_upperBasin','RRB_KS_lowerBasin')
rrbstates3 <- rrbstates3[,c('masterID','STATE_ABBR','STATE_FIPS','areakm2')]
#writeOGR(rrbstates3, outDir, 'RRB_byState_KS_split_aea', driver='ESRI Shapefile')


# RRCA-RRB intersection, and by state -------------
rrca.rrb <- raster::intersect(bound, rrb)
rrca.rrb$masterID <- c('RRCARRB_intersection')
rrca.rrb$areakm2 <- gArea(rrca.rrb, byid=T) * 1e-6
rrca.rrb <- rrca.rrb[,c('masterID','areakm2')]

# by state
rrca.rrb.states <- raster::intersect(rrca.rrb, states)
rrca.rrb.states$masterID <- c('RRCARRB_NE','RRCARRB_CO','RRCARRB_KS')
rrca.rrb.states$areakm2 <- gArea(rrca.rrb.states, byid=T) * 1e-6
rrca.rrb.states <- rrca.rrb.states[,c('masterID','areakm2','STATE_FIPS','STATE_ABBR')]

plot(rrca.rrb.states, main = 'RRCA-RRB Intersection')
plot(rrca.rrb.states[rrca.rrb.states$STATE_ABBR == 'NE',], add=T, col='blue')
plot(rrca.rrb.states[rrca.rrb.states$STATE_ABBR == 'KS',], add=T, col='red')
plot(rrca.rrb.states[rrca.rrb.states$STATE_ABBR == 'CO',], add=T, col='green')

## export
#writeOGR(rrca.rrb, outDir, 'RRCA-RRB_interesection_aea', driver='ESRI Shapefile')
#writeOGR(rrca.rrb.states, outDir, 'RRCA-RRB_interesection_byState_aea', driver='ESRI Shapefile')

# platte area of the rrca ---------------------
NErrca <- rrcastates[rrcastates$STATE_ABBR == 'NE',]
NErrb <- rrbstates3[rrbstates3$STATE_ABBR == 'NE',]

# get nonconsense areas of the NE RRCA and NE RRB
NEplatte <- gDifference(NErrca, NErrb)
NEplatte <- SpatialPolygonsDataFrame(NEplatte, match.ID=F,
                                         data.frame(masterID='Platte-NE_RRCA'))
# break into sub polygons and remove small slivers along KS border
NEplatte2 <- disaggregate(NEplatte)
NEplatte2$areakm2 <- gArea(NEplatte2, byid=T)
NEplatte3 <- NEplatte2[NEplatte2$areakm2 > 1e3,]

# look at Driver Analysis Regions? ---------------------

# KS gw
KS.gw.up <- rrcastates[rrcastates$masterID == 'RRCA_mod_KS',]
KS.gw.up2 <- disaggregate(KS.gw.up)
KS.gw.up2$areakm2 <- gArea(KS.gw.up2, byid=T) * 1e-6
KS.gw.up3 <- KS.gw.up2[KS.gw.up2$areakm2 > 100,]

plot(rrbstates3, border='white', main = 'Analysis Regions')
plot(rrca.rrb.states[rrca.rrb.states$STATE_ABBR == 'NE',], add=T, col='blue')
plot(KS.gw.up3, add=T, col = 'purple')
plot(rrca.rrb.states[rrca.rrb.states$STATE_ABBR == 'KS',], add=T, col='purple4')
plot(rrcastates[rrcastates$STATE_ABBR == 'CO',], add=T, col='green4')
plot(rrca.rrb.states[rrca.rrb.states$STATE_ABBR == 'CO',], add=T, col='green')
plot(NEplatte3, add=T, col='yellow')
plot(rrbstates3[rrbstates3$masterID == 'RRB_KS_lowerBasin',], add=T, col='orange')

```


