---
title: "Create Validation Points"
author: "Jill Deines"
date: "Thursday, May 19, 2016"
output: 
  html_document:
    toc: yes
---

Goal: Create a set of validation points to be used in evaluating irrigation maps produced from remote sensing classifications. The aim is to have random points stratified among different crop types as well as non-ag land.

I plan to split the points into 3 files to help Jeremey Rapp prioritize aerial image validation so I can get started. 

* Middle Republican NRD, NE
* Republican River Basin/RRCA groundwater model
* The rest of the HPA

```{r knitrOpts, echo=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE, cache.path='cache/1.1_vPOints/',
               fig.path='figure/1.1_vPoints/')
```

**R Packages Needed**

```{r packages, message=FALSE, echo=TRUE}
library(rgdal)
library(raster)
library(rgeos)
library(dplyr)
```

## Load Stuff
CDL for 2011 downloaded from Cropscape on 05/28/2016 and re-formatted via R to reduce file size. It's AOI is the HPA aquifer + RRCA/RRB buffer.

(update: done with 2010)

Also load the CDL csv key (the updated, consistent key across all years), and polygons for area extent.

All polygons are re-projected to match CDL projection. Must use a meters based projection for sampling function defined below.


```{r loadStuff}
# ## load original cdl download and write out smaller
# reduce <- raster('F:/deinesji/CDL/zipDownloads/CDL_2010_20160531123051_666969309.tif')
# writeRaster(reduce, 'F:/deinesji/CDL/hpa_rrbbuff/CDL_2010_HPA_RRB.tif',
#             datatype = 'INT1U')

#cdl and key
cdl <- raster('S:/Users/deinesji/HPA/gis/CDL/fullHPA/CDL_2010_HPA_RRB.tif')
cdlKey <- read.csv('S:/Users/deinesji/HPA/gis/CDL/CDL_key_2014.csv', 
                   stringsAsFactors=F)

# projection datum not read in for cdl, fix 
tweakProj <- "+proj=aea +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"
proj4string(cdl) <- tweakProj


# Jill's HPA gis dir
gisDir <- 'S:/Users/deinesji/HPA/gis'


# big RRB/RRCA boundary and transform to AEA proj
rrcabuff <- readOGR(gisDir, 'BigExtent_RRB_RRCA_buff', 
                    verbose=F)
rrcabuff <- spTransform(rrcabuff, CRS(tweakProj))

# Middle Republican RRB (smaller area for testing)
nrds <-  readOGR(gisDir, 'RRB_NRDs', verbose=F)
midRep <- nrds[nrds$NRD_Name == 'Middle Republican',]
midRep <- spTransform(midRep, CRS(tweakProj))

# HPA (no buffer)
hpa <- readOGR(gisDir, 'Aquifer_Regions_dissolve', verbose=F)
hpa <- spTransform(hpa, CRS(tweakProj))
```



## Define Stratified sampling function
Overview: turns the CDL raster into a data frame and performs stratified random sampling on CDL classes. Then converts data frame back to spatialPointsDataFrame. This is intended to be used on a cdl raster that has already been masked by a polygon area of interest. Polygon should be in same projected coordinates as CDL layer

Because grassland is such a huge proportion of the landscape but relatively easy to classify as irr/nonirr, the function "downweights" this crop class. It does this in a gangsta way by increasingly the # points desired, and then removing a percentage of the grassland points based on argument 'grassthin'.

The following CDL classes are also removed from the sample: Any CDL class with 'DEVELOPED' in it is also removed from the sample, forests, and wetlands. While this could somewhat alter the density, I'm not too worried since they are relatively rare on the HPA landscape.

Function arguments:

* cdl.mask: a cdl raster masked to polygon of interest. Masking is important so that cells outside the polgyon boundary are NA.
* poly: a polygon of interest in same projection as CDL, meters based
* sampleDensity: Put a point every "this many" square kilometers. Brown and Pervez 2010 ranged from every 19.3 km2 to 96.7 km2 and didn't see a difference in reported accuracy.
* cdlKey: name of R object for the CDL csv key Jill created from Cropscape dbf's
* seed: default set to 1 so function reproduces the same point dataset each time. User can change to any number to set a different random draw of points.
* sampleFactor: amount to increase number of sample points to offset grassland thinning
* grassThin: percentage (approximate due to random rbinom draw) of grassland points to keep. 


```{r stratFun}

getStratCdl <- function(cdl.mask, poly, sampleDensity, sampleFactor, 
                        grassThin, cdlKey, seed=1){
  # get poly area and number of target points
  area <- gArea(poly) 
  area.km2 <- area*1e-6
  pointsDesired <- area.km2/sampleDensity
    
  # convert to df, rename columns, and remove NAs
  r.points <- as.data.frame(cdl.mask, xy = T, centroids=T)
  names(r.points) <- c('x','y','CDLcode')
  r.points <- r.points[!is.na(r.points$CDLcode),]
   
  # convert points desired to sample fraction
  ncells <- dim(r.points)[1]
  # inflate samFrac to allow downscale pruning of grassland samples
  samFrac <- (pointsDesired*sampleFactor)/ncells
  
  # take a proportional sample from all classes
  set.seed(seed)                        
  p1.r <- r.points %>%
          group_by(CDLcode) %>%
          sample_frac(size = samFrac)

    # add crop key (do after sampling if final method)
  p1.r2 <- merge(p1.r, cdlKey[,c('VALUE','CLASS_NAME')], 
            by.x='CDLcode', by.y='VALUE', all.y = F)

  # thin grassland
  p1.r2$keep <- 1  
  # update 'keep' binary based on a random assigmnet of 0,1 to grassland class
  grassSamples <- sum(p1.r2$CLASS_NAME == 'Grass/Pasture') # get number
  set.seed(seed)
  p1.r2[p1.r2$CLASS_NAME == 'Grass/Pasture','keep'] <- rbinom(grassSamples, 1, grassThin)  
  # flag developed classes for removal as well
  p1.r2[grepl('Developed',p1.r2$CLASS_NAME),'keep'] <- 0
  # flag forests and wetlands for removal, and water
  p1.r2[grepl('Forest',p1.r2$CLASS_NAME),'keep'] <- 0
  p1.r2[grepl('Wetlands',p1.r2$CLASS_NAME),'keep'] <- 0
  p1.r2[grepl('Water',p1.r2$CLASS_NAME),'keep'] <- 0
  
  # remove points
  p1.r2 <- p1.r2[p1.r2$keep ==1,]
  # drop keep column
  p1.r2 <- p1.r2[,c('CDLcode','CLASS_NAME','x','y')]

  # turn back to spatial points
  coordinates(p1.r2) <- ~ x + y
  proj4string(p1.r2) <- tweakProj
  
  return(p1.r2)  
}

```

## Make Point Datasets

### Middle Republican
I might try evaluating classifications in this NRD

```{r midRep}
# # # crop CDL
# cdl.crop2 <- crop(cdl, midRep)
# cdl.mask2 <- mask(cdl.crop2, midRep)
# # 
# # # write out crop mask so faster next time
# writeRaster(cdl.mask2, dataType = 'INT1U', filename = 'S:/Users/deinesji/HPA/gis/CDL/rsValidationMaskedSets/2010_midRepMask.tif')

# load previously masked
cdl.mask.midRep <- raster('S:/Users/deinesji/HPA/gis/CDL/rsValidationMaskedSets/2010_midRepMask.tif')
proj4string(cdl.mask.midRep) <- tweakProj

# get points!
ptDensity.nrd <- 10 # 1 point per every "x" km2 
grasslandThin <- 0.3 # keep 30% of grassland points
sampleFactor <- 1.9 # increase sample points to offset grassland and CDL category thinning

# generate stratified random sample
nrdPoints <- getStratCdl(cdl.mask.midRep, midRep, ptDensity.nrd, sampleFactor,
                         grasslandThin, cdlKey, seed=1)

# see how points cover classes
table(nrdPoints@data$CLASS_NAME)
  
# view
plot(cdl.mask.midRep)
plot(nrdPoints, add=T, pch = 19)

# see how close to target density after grassland/developed thinning
dim(nrdPoints)[1]
gArea(midRep)*1e-6/ptDensity.nrd
```

Note: alfalfa is low to reliably get samples for irrigated/non-irrigated alfalfa

```{r nrdWrite, eval=TRUE}
# write out as WGS84 (needed for kml)
nrdPoints.ll <- spTransform(nrdPoints, CRS("+proj=longlat +datum=WGS84"))
outdir <- 'S:/Users/deinesji/HPA/gis/GEE_processing/validPoints'
writeOGR(nrdPoints.ll, outdir, 'valid_MidRep_10_2010_20160725', driver='ESRI Shapefile', 
         overwrite = F)
writeOGR(nrdPoints.ll, paste0(outdir, '/valid_MidRep_10_2010_20160725.kml'),
            layer = 'thislayer', driver='KML', overwrite=F)

# write KML to my dropbox for laptop access 
writeOGR(nrdPoints.ll, 'C:/Users/deinesji/Dropbox/1PhdJill/hpa/irrigation/data/GIS/validation/generatedPointsForUpload/valid_MidRep_10_2010_20160725.kml', layer = 'thislayer', driver='KML', overwrite=F)
```

### Republican River Basin
including RRCA model domain

```{r rrca, eval=FALSE}
# crop CDL
cdl.crop3 <- crop(cdl, rrcabuff)
cdl.mask3 <- mask(cdl.crop3, rrcabuff)

# get points!
ptDensity <- 100 # 1 point per every 100 km2 

# time run
start.time <- Sys.time()

rrcaPoints <- getStratCdl(cdl.mask3, rrcabuff, ptDensity, cdlKey, seed=1)
  
end.time <- Sys.time()
time.taken <- end.time - start.time
```


### Full Study Area
Extent of the High Plains Aquifer + the full Republican River Basin (some sticks out)

**Prior to generating points for the full area, I will likely do additional masks of urban areas, etc, to increase point density on areas of interest**

```{r fullPoints, eval=FALSE}
# union the HPA extent and RRCA buffer
fullArea <- gUnion(hpa, rrcabuff)

# crop CDL
cdl.crop <- crop(cdl, fullArea)
cdl.mask <- mask(cdl.crop, fullArea)

# get points!
ptDensity <- 200 # 1 point per every 100 km2 

# time run
start.time <- Sys.time()

fullPoints <- getStratCdl(cdl.mask, fullArea, ptDensity, cdlKey, seed=1)
  
end.time <- Sys.time()
time.taken <- end.time - start.time
```


## Old Development Process and Brainstorming
I want stratified random samples based on crop classes and non-crop. I could make a point for every raster cell, convert that to a data frame, and then take stratified samples from there. This would also allow me to make a few different sized sets of points.

But then points are regular, not random. Make random points, then stratify?

## Middle Republican NRD test

### Method 1: Random points
Generate random points, extract raster CDL values, tabulate

(No control over stratification - could generate more points and thin)

I use method 2.

```{r midRep_test, eval=FALSE}
# Middle Republican RRB (smaller area for testing)
nrds <-  readOGR('S:/Users/deinesji/HPA/gis', 'RRB_NRDs', verbose=F)
midRep <- nrds[nrds$NRD_Name == 'Middle Republican',]
midRep <- spTransform(midRep, CRS(tweakProj))

# get area of buffer
nrdArea <- gArea(midRep)
nrdkm2 <- nrdArea * 1e-6
nrdkm2  # square kilometers

# desired point numbers to mimic density in Brown and Pervez 2010
nrdkm2/100 # min number of points?
nrdkm2/20 # max number of points

# generate random points
npoints <- 500
p1 <- spsample(midRep, n =npoints, "random")
plot(midRep)
plot(p1, add=T, pch=19)

# conver to spdf
p1 <- SpatialPointsDataFrame(p1, data=data.frame(ID=1:npoints))

# add CDL crop type from raster and category name from key
p1$CDLcode <- extract(cdl, p1)
p1 <- merge(p1, cdlKey[,c('VALUE','CLASS_NAME')], 
            by.x='CDLcode', by.y='VALUE', all.y = F)

# tabulate to see class representations
classTab <- table(p1$CLASS_NAME)
```


### Method 2: Raster to Points (use this)
Convert Raster to a point dataset -> data.frame, and do stratified random sampling from there

```{r methodTest2, eval=FALSE}
# crop CDL to NRD
cdl.mr <- crop(cdl, midRep)

# convert to df
r.points <- as.data.frame(cdl.mr, xy = T, centroids=T)
names(r.points) <- c('x','y','CDLcode')

# take a proportional sample from all classes
set.seed(1)
p1.r <- r.points %>%
          group_by(CDLcode) %>%
          sample_frac(size = 4/100000)

# add crop key (do after sampling if final method)
r.points <- merge(p1.r, cdlKey[,c('VALUE','CLASS_NAME')], 
            by.x='CDLcode', by.y='VALUE', all.y = F)

classTab.r <- table(p1.r$CLASS_NAME)
```

